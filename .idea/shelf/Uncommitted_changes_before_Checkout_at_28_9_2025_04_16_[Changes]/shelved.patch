Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>### LungLife - Early Cancer Detection & Predictive Analytics.\r\n\r\n#### Descripción General\r\n\r\nEl cáncer es una enfermedad grave que puede invadir los órganos vitales y en muchas ocasiones ser mortal, según las estadísticas, es la segunda causa de muerte en Chile y a nivel mundial, sin embargo, un diagnóstico temprano mejora considerablemente la expectativa de vida de las personas afectadas por esta enfermedad. El machine learning es de gran utilidad en el diagnóstico precoz del cáncer, los sistemas que lo incorporan pueden «aprender» sobre esta enfermedad y detectar una dolencia con la misma exactitud que un médico y comenzar a tratar los síntomas de la enfermedad cuando antes, incluso antes de que llegue a manifestarse.  \r\n\r\nEl objetivo de este proyecto es desarrollar un sistema que prediga el cáncer en pacientes por medios de machine learning con metodologías CRISP-DM junto a un app mobile en base de ionic, que permita predecir si un paciente o varios pacientes pueden tener cáncer,identificar los factores de riesgos de estos pacientes, responder 5 preguntas de negocio y mostrar resultados predictivos utilizando Power BI, considerando la funcionalidad, usabilidad y confiabilidad del sistema, teniendo como usuarios finales personal de salud y usuario paciente.  \r\n\r\nLa justificación de este proyecto radica en la urgente necesidad de desarrollar herramientas tecnológicas que apoyen la detección precoz del cáncer, específicamente el cáncer pulmonar, dado su impacto epidemiológico. El uso de machine learning permite analizar grandes volúmenes de datos clínicos y ambientales para identificar patrones predictivos con una precisión comparable a la de un especialista, facilitando diagnósticos antes de la aparición de síntomas. Este proyecto se propone cerrar la brecha en la detección temprana mediante un sistema que no solo predice la probabilidad de cáncer en pacientes, sino que también identifica factores de riesgo clave, optimizando la toma de decisiones clínicas y reduciendo la carga en los sistemas de salud.  \r\n\r\n#### Arquitectura del Sistema\r\n\r\n#### Frontend Mobile (Ionic + Angular Standalone)\r\n\r\n- **Framework**: Ionic Framework con Angular Standalone Components\r\n- **Lenguaje**: TypeScript\r\n- **Estilos**: SCSS con sistema de temas\r\n- **Patrón**: Clean Architecture con separación de capas  \r\n\r\n#### Backend API (Node.js + TypeScript)\r\n\r\n- **Framework**: Express.js con TypeScript\r\n- **Base de Datos**: PostgreSQL local\r\n- **Autenticación**: JWT con estrategias múltiples\r\n- **Patrón**: Arquitectura en capas (Controllers → Services → Models)  \r\n\r\n#### Base de Datos (PostgreSQL)\r\n\r\n- **Tipo**: Base de datos relacional local\r\n- **Esquemas**: Autenticación completa, perfiles de usuario, logs de auditoría\r\n- **Migraciones**: Scripts SQL organizados  \r\n\r\n#### Machine Learning (Python + CRISP-DM)\r\n\r\n- **Metodología**: CRISP-DM (Cross Industry Standard Process for Data Mining)\r\n- **Herramientas**: Jupyter Notebooks, Scikit-learn, Pandas\r\n- **Visualización**: PowerBI para dashboards interactivos  \r\n\r\n#### Atributos de Calidad\r\n\r\n#### Mantenibilidad\r\n\r\n- **Modularidad**: Arquitectura modular con feature modules\r\n- **Clean Code**: Convenciones de nomenclatura consistentes\r\n- **Documentación**: README, comentarios en código, documentación de API  \r\n\r\n#### Usabilidad\r\n\r\n- **Responsive Design**: Mobile-first con soporte cross-platform\r\n- **UI Consistency**: Sistema de diseño unificado\r\n- **User Feedback**: Estados de carga, mensajes de error, notificaciones  \r\n\r\n#### Escalabilidad\r\n\r\n- **Layered Architecture**: Separación clara de responsabilidades\r\n- **Dependency Injection**: Inyección de dependencias para testing y flexibilidad\r\n- **Microservices Ready**: Arquitectura preparada para migración a microservicios  \r\n\r\n#### Confiabilidad\r\n\r\n- **Error Handling**: Manejo robusto de errores en todas las capas\r\n- **Logging**: Sistema de logging estructurado\r\n- **Testing**: Tests unitarios e integración  \r\n\r\n#### Google Colab\r\n\r\nLa elección de Google Colaboratory (Colab) como plataforma para un proyecto de machine learning ofrece una base sólida y eficiente desde el inicio. Esta herramienta basada en la nube elimina las barreras de configuración de entorno, proporcionando acceso gratuito a recursos computacionales potentes como GPUs, esenciales para acelerar el entrenamiento de modelos complejos. Su entorno interactivo de notebooks, basado en Jupyter, es ideal para el desarrollo de un flujo de trabajo secuencial que abarca desde la carga y exploración de datos hasta el entrenamiento y la evaluación de algoritmos. Además, su integración nativa con Google Drive simplifica enormemente el manejo de datasets, el control de versiones de los notebooks y la persistencia de los modelos entrenados, permitiendo que el enfoque se centre directamente en la experimentación y el desarrollo desde el primer momento.  \r\n\r\n**[Google Drive CRISP-DM](https://drive.google.com/drive/folders/1PfLfkxpk_ykxriyJQuFAnnRtgT9plHA8?usp=drive_link)**  \r\n\r\n#### CRISP-DM\r\n\r\n[Business Understand](https://colab.research.google.com/drive/1-_ws0-wYwStwEON1uKARBl6UNOegKZo-?authuser=1)  \r\n[Data Understand](https://colab.research.google.com/drive/1Zf6HPZYlpLpLnplN92aQG4ajqO8mc-5e?authuser=1)  \r\n[Data Preparation](https://colab.research.google.com/drive/1n6MeKtCK6GX_o4FPIcqialJdO3vufyhn?authuser=1)  \r\n[Modeling](https://colab.research.google.com/drive/1rgKTA53S9-GKi3ruG0hF2FAsD1_900LI?authuser=1)  \r\n[Evaluation](https://colab.research.google.com/drive/1upzA1r_le8WYYV54FDa78P-7Gxds_mQv?authuser=1)  \r\n[Deployment](https://colab.research.google.com/drive/19wDxKsoqpfZHwMKHP5IfgWNA8-CHoEM9?authuser=1)  \r\n\r\n###### Estructura de directorios LungLife_ml\r\n\r\n<pre style=\"font-size: 14px;\">\r\ncrisp_dm/                            # Carpeta principal en Google Drive\r\n│\r\n├── data/                            # Almacenamiento de datos\r\n│   ├── raw/                         # Datos originales\r\n│   ├── processed/                   # Datos listos para modelado\r\n│   └── external/                    # Datos externos (opcional)\r\n│\r\n├── database/                        # Base de datos\r\n│\r\n├── notebooks/                       # Jupyter notebooks para CRISP-DM\r\n│   ├── 01_business_understanding.ipynb\r\n│   ├── 02_data_understanding.ipynb\r\n│   ├── 03_data_preparation.ipynb\r\n│   ├── 04_modeling.ipynb\r\n│   ├── 05_evaluation.ipynb\r\n│   ├── 06_deployment.ipynb\r\n│   └── 06_powerbi_visualization.ipynb\r\n│\r\n├── src/                             # Código fuente\r\n│\r\n├── models/                          # Modelos entrenados\r\n│\r\n├── config/                          # Configuraciones\r\n│\r\n├── docs/                            # Documentación\r\n│\r\n├── visualizations/                  # Visualizaciones\r\n│\r\n├── tests/                           # Pruebas unitarias\r\n│\r\n├── requirements.txt                 # Dependencias del proyecto\r\n└── README.md                        # Documentación principal  \r\n</pre>\r\n\r\n####Jira Herramienta de Seguimiento SCRUM - Metodología Ágil  \r\n\r\n###### Fundamentación Estratégica\r\n\r\nLa implementación de Atlassian Jira como plataforma central de gestión ágil para el proyecto LungLife responde a la necesidad crítica de mantener trazabilidad completa, transparencia operacional, y alineación estratégica en un proyecto de desarrollo de  software. Jira se posiciona como la solución óptima debido a su arquitectura especializada para metodologías SCRUM, su capacidad de integración nativa con repositorios de código (GitHub), y su robusta funcionalidad de reporting y métricas ágiles esenciales para la toma de decisiones basada en datos.  \r\n\r\n1. __Gestión Nativa de Artefactos SCRUM:__  \r\n\r\n__Product Backlog:__ Organización jerárquica de Epics, Stories, y Tasks con priorización dinámica  \r\n__Sprint Backlog:__ Planificación detallada con estimación en Story Points y capacidad de equipo  \r\n__Sprint Board:__ Visualización Kanban en tiempo real (To Do, In Progress, Code Review, Done)  \r\n__Burndown Charts:__ Monitoreo automático del progreso del sprint y velocity del equipo  \r\n2. __Roles y Responsabilidades Definidas:__  \r\n\r\n__Product Owner:__ Control total sobre backlog prioritization y acceptance criteria  \r\n__Scrum Master:__ Dashboards especializados para identificar impedimentos y métricas de rendimiento  \r\n__Development Team:__ Asignación transparente de tareas con tracking de tiempo y esfuerzo  \r\n3. __Ceremonias SCRUM Optimizadas:__  \r\n\r\n__Sprint Planning:__ Templates automatizados con estimación colaborativa y capacity planning  \r\n__Daily Standups:__ Reportes automáticos de progreso y bloqueos identificados  \r\n__Sprint Review:__ Documentación automática de deliverables y demo tracking\r\nRetrospectives: Plantillas estructuradas para continuous improvement actions\r\n\r\n#### Repositorio GitHub\r\n\r\nEl repositorio PTY4614 [Github-LungLife](https://github.com/secarvallo/PTY4614) constituye el núcleo de desarrollo colaborativo para el proyecto LungLife, una solución de App Mobile + Machine Learning enfocada en el diagnóstico temprano del cancer de pulmon. La elección de GitHub como plataforma de control de versiones se fundamenta en su robusta integración con herramientas de desarrollo modernas, capacidades avanzadas de CI/CD a través de GitHub Actions, y su ecosistema completo que incluye gestión de issues, pull requests, y wikis para documentación técnica. Esta plataforma facilita la colaboración entre equipos multidisciplinarios de desarrollo, proporcionando trazabilidad completa del código, versionado semántico, y controles de calidad esenciales para el proyecto de software.  \r\n\r\n#### Estrategía de Branching\r\n\r\n###### Flujo de Ramas de Publicación en GitHub\r\n\r\nEl flujo de publicación en GitHub sigue un patrón estructurado que garantiza la calidad y estabilidad del código. Inicia con la creación de ramas feature/ desde develop para nuevas funcionalidades, donde los desarrolladores implementan cambios específicos vinculados a tickets de Jira. Una vez completado el desarrollo, se crea un Pull Request (PR) hacia develop, donde se ejecutan automáticamente las pruebas de CI/CD, revisiones de código por pares y validaciones de calidad. Tras la aprobación y merge, los cambios se integran en develop para testing conjunto. Cuando se acumulan suficientes features, se crea una rama release/ que se somete a pruebas exhaustivas de QA antes de hacer merge a main/master para producción. En casos críticos, las ramas hotfix/ permiten correcciones directas desde main con despliegue inmediato. Este flujo asegura trazabilidad completa desde el desarrollo hasta producción, manteniendo la integridad del código y facilitando rollbacks cuando sea necesario.  \r\n![Ramas de publicación](https://wac-cdn.atlassian.com/dam/jcr:8f00f1a4-ef2d-498a-a2c6-8020bb97902f/03%20Release%20branches.svg)  \r\n\r\n#### Principales Ramas de Trabajo LungLife\r\n\r\n###### Ramas Principales\r\n\r\n__main/master__    # Código en producción, versión estable  \r\n__develop__        # Rama principal de desarrollo, integración continua  \r\n\r\n1. __Ramas de Desarrollo de Funcionalidades__  \r\n   __feature/LUNG-XXX-nombre__    # Nuevas funcionalidades con ticket Jira  \r\n   __ml/experiment-name__         # Experimentos y modelos de machine learning  \r\n   __refactor/component-name__    # Reestructuración y optimización de código  \r\n2. __Ramas de Corrección y Mantenimiento__  \r\n   __bugfix/LUNG-XXX-issue__     # Corrección de errores no críticos  \r\n   __hotfix/LUNG-XXX-critical__  # Correcciones críticas urgentes en producción  \r\n   __patch/LUNG-XXX-minor__      # Correcciones menores y ajustes rápidos  \r\n   __maintenance/task-name__     # Tareas de mantenimiento y limpieza de código  \r\n3. __Ramas de Interfaz de Usuario__  \r\n   __ui/design-system-v2__       # Sistema de diseño, componentes reutilizables  \r\n   __ux/user-journey-fix__       # Optimización de experiencia de usuario  \r\n   __frontend/feature-name__     # Desarrollo específico de frontend   \r\n4. __Ramas de Backend e Infraestructura__  \r\n   __backend/api-endpoint__      # Desarrollo de APIs y lógica de servidor  \r\n   __infra/aws-setup__          # Configuración de infraestructura(cloud,servidores)  \r\n   __devops/pipeline-config__   # Automatización, CI/CD, contenedores   \r\n5. __Ramas de Despliegue y Entornos__  \r\n   __release/v1.2.0__           # Preparación de versiones para release  \r\n   __deploy/staging-config__    # Configuración específica de despliegues  \r\n   __config/environment-vars__  # Variables de entorno y configuraciones  \r\n   __setup/development-env__    # Setup inicial de entornos de desarrollo   \r\n6. __Ramas de Testing y Calidad__  \r\n   __test/integration-suite__   # Tests automatizados e integración  \r\n   __qa/regression-testing__    # Pruebas de calidad y regresión     \r\n7. __Ramas de Documentación y Gestión__  \r\n   __docs/api-documentation__   # Documentación técnica y de usuario  \r\n   __github/workflow-setup__    # Configuración de GitHub (templates, actions)  \r\n   __jira/automation-rules__    # Integración y automatización con Jira  \r\n   __privacy/gdpr-compliance__  # Cumplimiento de privacidad y regulaciones   \r\n\r\n#### Configuración de Entornos & Tools Env.\r\n\r\n###### IDE Visual Studio Code\r\n\r\n    August 2025 (version 1.104)\r\n\r\nRelease date: September 11, 2025\r\nUpdate 1.104.1: The update addresses these issues.\r\nUpdate 1.104.2: The update addresses these issues.   \r\n\r\n###### IDE JETBRAINS\r\n\r\n###### DataSpell 2025.2\r\n\r\n    Build #DS-252.23892.514, built on August 11, 2025  \r\n\r\n###### WebStorm 2025.2.2\r\n\r\n    Build #WS-252.26199.162, built on September 18, 2025 \r\n\r\n##### Data Base\r\n\r\n##### PosgreSQL\r\n\r\n    pgAdmin 4 Version 9.8\r\n\r\n##### Abricotine\r\n\r\n    Abricotine - Markdown Editor\r\n    Copyright (c) 2020 Thomas Brouard\r\n\r\n> This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
--- a/README.md	(revision 04733818b03611329dfb1300812a061930246582)
+++ b/README.md	(date 1759043651306)
@@ -1,13 +1,13 @@
 ### LungLife - Early Cancer Detection & Predictive Analytics.
-
 #### Descripción General
 
-El cáncer es una enfermedad grave que puede invadir los órganos vitales y en muchas ocasiones ser mortal, según las estadísticas, es la segunda causa de muerte en Chile y a nivel mundial, sin embargo, un diagnóstico temprano mejora considerablemente la expectativa de vida de las personas afectadas por esta enfermedad. El machine learning es de gran utilidad en el diagnóstico precoz del cáncer, los sistemas que lo incorporan pueden «aprender» sobre esta enfermedad y detectar una dolencia con la misma exactitud que un médico y comenzar a tratar los síntomas de la enfermedad cuando antes, incluso antes de que llegue a manifestarse.  
+
+El cáncer es una enfermedad grave que puede invadir los órganos vitales y en muchas ocasiones ser mortal, según las estadísticas, es la segunda causa de muerte en Chile y a nivel mundial, sin embargo, un diagnóstico temprano mejora considerablemente la expectativa de vida de las personas afectadas por esta enfermedad. El machine learning es de gran utilidad en el diagnóstico precoz del cáncer, los sistemas que lo incorporan pueden «aprender» sobre esta enfermedad y detectar una dolencia con la misma exactitud que un médico y comenzar a tratar los síntomas de la enfermedad cuando antes, incluso antes de que llegue a manifestarse.
 
-El objetivo de este proyecto es desarrollar un sistema que prediga el cáncer en pacientes por medios de machine learning con metodologías CRISP-DM junto a un app mobile en base de ionic, que permita predecir si un paciente o varios pacientes pueden tener cáncer,identificar los factores de riesgos de estos pacientes, responder 5 preguntas de negocio y mostrar resultados predictivos utilizando Power BI, considerando la funcionalidad, usabilidad y confiabilidad del sistema, teniendo como usuarios finales personal de salud y usuario paciente.  
+El objetivo de este proyecto es desarrollar un sistema que prediga el cáncer en pacientes por medios de machine learning con metodologías CRISP-DM junto a un app mobile en base de ionic, que permita predecir si un paciente o varios pacientes pueden tener cáncer,identificar los factores de riesgos de estos pacientes, responder 5 preguntas de negocio y mostrar resultados predictivos utilizando Power BI, considerando la funcionalidad, usabilidad y confiabilidad del sistema, teniendo como usuarios finales personal de salud y usuario paciente.
 
-La justificación de este proyecto radica en la urgente necesidad de desarrollar herramientas tecnológicas que apoyen la detección precoz del cáncer, específicamente el cáncer pulmonar, dado su impacto epidemiológico. El uso de machine learning permite analizar grandes volúmenes de datos clínicos y ambientales para identificar patrones predictivos con una precisión comparable a la de un especialista, facilitando diagnósticos antes de la aparición de síntomas. Este proyecto se propone cerrar la brecha en la detección temprana mediante un sistema que no solo predice la probabilidad de cáncer en pacientes, sino que también identifica factores de riesgo clave, optimizando la toma de decisiones clínicas y reduciendo la carga en los sistemas de salud.  
-
+La justificación de este proyecto radica en la urgente necesidad de desarrollar herramientas tecnológicas que apoyen la detección precoz del cáncer, específicamente el cáncer pulmonar, dado su impacto epidemiológico. El uso de machine learning permite analizar grandes volúmenes de datos clínicos y ambientales para identificar patrones predictivos con una precisión comparable a la de un especialista, facilitando diagnósticos antes de la aparición de síntomas. Este proyecto se propone cerrar la brecha en la detección temprana mediante un sistema que no solo predice la probabilidad de cáncer en pacientes, sino que también identifica factores de riesgo clave, optimizando la toma de decisiones clínicas y reduciendo la carga en los sistemas de salud.
+	
 #### Arquitectura del Sistema
 
 #### Frontend Mobile (Ionic + Angular Standalone)
@@ -15,26 +15,26 @@
 - **Framework**: Ionic Framework con Angular Standalone Components
 - **Lenguaje**: TypeScript
 - **Estilos**: SCSS con sistema de temas
-- **Patrón**: Clean Architecture con separación de capas  
+- **Patrón**: Clean Architecture con separación de capas
 
 #### Backend API (Node.js + TypeScript)
 
 - **Framework**: Express.js con TypeScript
 - **Base de Datos**: PostgreSQL local
 - **Autenticación**: JWT con estrategias múltiples
-- **Patrón**: Arquitectura en capas (Controllers → Services → Models)  
+- **Patrón**: Arquitectura en capas (Controllers → Services → Models)
 
 #### Base de Datos (PostgreSQL)
 
 - **Tipo**: Base de datos relacional local
 - **Esquemas**: Autenticación completa, perfiles de usuario, logs de auditoría
-- **Migraciones**: Scripts SQL organizados  
+- **Migraciones**: Scripts SQL organizados
 
 #### Machine Learning (Python + CRISP-DM)
 
 - **Metodología**: CRISP-DM (Cross Industry Standard Process for Data Mining)
 - **Herramientas**: Jupyter Notebooks, Scikit-learn, Pandas
-- **Visualización**: PowerBI para dashboards interactivos  
+- **Visualización**: PowerBI para dashboards interactivos
 
 #### Atributos de Calidad
 
@@ -42,180 +42,61 @@
 
 - **Modularidad**: Arquitectura modular con feature modules
 - **Clean Code**: Convenciones de nomenclatura consistentes
-- **Documentación**: README, comentarios en código, documentación de API  
+- **Documentación**: README, comentarios en código, documentación de API
 
 #### Usabilidad
 
 - **Responsive Design**: Mobile-first con soporte cross-platform
 - **UI Consistency**: Sistema de diseño unificado
-- **User Feedback**: Estados de carga, mensajes de error, notificaciones  
+- **User Feedback**: Estados de carga, mensajes de error, notificaciones
 
 #### Escalabilidad
 
 - **Layered Architecture**: Separación clara de responsabilidades
 - **Dependency Injection**: Inyección de dependencias para testing y flexibilidad
-- **Microservices Ready**: Arquitectura preparada para migración a microservicios  
+- **Microservices Ready**: Arquitectura preparada para migración a microservicios
 
 #### Confiabilidad
 
 - **Error Handling**: Manejo robusto de errores en todas las capas
 - **Logging**: Sistema de logging estructurado
-- **Testing**: Tests unitarios e integración  
+- **Testing**: Tests unitarios e integración
 
-#### Google Colab
-
-La elección de Google Colaboratory (Colab) como plataforma para un proyecto de machine learning ofrece una base sólida y eficiente desde el inicio. Esta herramienta basada en la nube elimina las barreras de configuración de entorno, proporcionando acceso gratuito a recursos computacionales potentes como GPUs, esenciales para acelerar el entrenamiento de modelos complejos. Su entorno interactivo de notebooks, basado en Jupyter, es ideal para el desarrollo de un flujo de trabajo secuencial que abarca desde la carga y exploración de datos hasta el entrenamiento y la evaluación de algoritmos. Además, su integración nativa con Google Drive simplifica enormemente el manejo de datasets, el control de versiones de los notebooks y la persistencia de los modelos entrenados, permitiendo que el enfoque se centre directamente en la experimentación y el desarrollo desde el primer momento.  
-
-**[Google Drive CRISP-DM](https://drive.google.com/drive/folders/1PfLfkxpk_ykxriyJQuFAnnRtgT9plHA8?usp=drive_link)**  
-
-#### CRISP-DM
-
-[Business Understand](https://colab.research.google.com/drive/1-_ws0-wYwStwEON1uKARBl6UNOegKZo-?authuser=1)  
-[Data Understand](https://colab.research.google.com/drive/1Zf6HPZYlpLpLnplN92aQG4ajqO8mc-5e?authuser=1)  
-[Data Preparation](https://colab.research.google.com/drive/1n6MeKtCK6GX_o4FPIcqialJdO3vufyhn?authuser=1)  
-[Modeling](https://colab.research.google.com/drive/1rgKTA53S9-GKi3ruG0hF2FAsD1_900LI?authuser=1)  
-[Evaluation](https://colab.research.google.com/drive/1upzA1r_le8WYYV54FDa78P-7Gxds_mQv?authuser=1)  
-[Deployment](https://colab.research.google.com/drive/19wDxKsoqpfZHwMKHP5IfgWNA8-CHoEM9?authuser=1)  
-
-###### Estructura de directorios LungLife_ml
-
-<pre style="font-size: 14px;">
-crisp_dm/                            # Carpeta principal en Google Drive
-│
-├── data/                            # Almacenamiento de datos
-│   ├── raw/                         # Datos originales
-│   ├── processed/                   # Datos listos para modelado
-│   └── external/                    # Datos externos (opcional)
-│
-├── database/                        # Base de datos
-│
-├── notebooks/                       # Jupyter notebooks para CRISP-DM
-│   ├── 01_business_understanding.ipynb
-│   ├── 02_data_understanding.ipynb
-│   ├── 03_data_preparation.ipynb
-│   ├── 04_modeling.ipynb
-│   ├── 05_evaluation.ipynb
-│   ├── 06_deployment.ipynb
-│   └── 06_powerbi_visualization.ipynb
-│
-├── src/                             # Código fuente
-│
-├── models/                          # Modelos entrenados
-│
-├── config/                          # Configuraciones
-│
-├── docs/                            # Documentación
-│
-├── visualizations/                  # Visualizaciones
-│
-├── tests/                           # Pruebas unitarias
-│
-├── requirements.txt                 # Dependencias del proyecto
-└── README.md                        # Documentación principal  
-</pre>
-
-####Jira Herramienta de Seguimiento SCRUM - Metodología Ágil  
+###	Estrategía de Branching
 
-###### Fundamentación Estratégica
+Flujo de Trabajo en GitHub (Branching Strategy)
 
-La implementación de Atlassian Jira como plataforma central de gestión ágil para el proyecto LungLife responde a la necesidad crítica de mantener trazabilidad completa, transparencia operacional, y alineación estratégica en un proyecto de desarrollo de  software. Jira se posiciona como la solución óptima debido a su arquitectura especializada para metodologías SCRUM, su capacidad de integración nativa con repositorios de código (GitHub), y su robusta funcionalidad de reporting y métricas ágiles esenciales para la toma de decisiones basada en datos.  
+#### Ramas de publicación
 
-1. __Gestión Nativa de Artefactos SCRUM:__  
+flujo GitFlow adaptado a Scrum para evitar conflictos en dupla:
 
-__Product Backlog:__ Organización jerárquica de Epics, Stories, y Tasks con priorización dinámica  
-__Sprint Backlog:__ Planificación detallada con estimación en Story Points y capacidad de equipo  
-__Sprint Board:__ Visualización Kanban en tiempo real (To Do, In Progress, Code Review, Done)  
-__Burndown Charts:__ Monitoreo automático del progreso del sprint y velocity del equipo  
-2. __Roles y Responsabilidades Definidas:__  
+__Branch principal (main):__ Solo merges aprobados. Representa versiones estables para despliegue.
 
-__Product Owner:__ Control total sobre backlog prioritization y acceptance criteria  
-__Scrum Master:__ Dashboards especializados para identificar impedimentos y métricas de rendimiento  
-__Development Team:__ Asignación transparente de tareas con tracking de tiempo y esfuerzo  
-3. __Ceremonias SCRUM Optimizadas:__  
+__Develop branch:__ Para integración continua. Mergea features aquí antes de main.
 
-__Sprint Planning:__ Templates automatizados con estimación colaborativa y capacity planning  
-__Daily Standups:__ Reportes automáticos de progreso y bloqueos identificados  
-__Sprint Review:__ Documentación automática de deliverables y demo tracking
-Retrospectives: Plantillas estructuradas para continuous improvement actions
+__Feature branches:__ Por task de Jira (e.g., "feature/predict-ml-model"). Cada miembro de la dupla trabaja en su branch.
 
-#### Repositorio GitHub
+__Pull Requests (PRs):__ Obligatorios para merges. El otro miembro revisa y aprueba. Usa templates de PR para incluir checklists (e.g., "Pruebas pasadas? Documentación actualizada?").
 
-El repositorio PTY4614 [Github-LungLife](https://github.com/secarvallo/PTY4614) constituye el núcleo de desarrollo colaborativo para el proyecto LungLife, una solución de App Mobile + Machine Learning enfocada en el diagnóstico temprano del cancer de pulmon. La elección de GitHub como plataforma de control de versiones se fundamenta en su robusta integración con herramientas de desarrollo modernas, capacidades avanzadas de CI/CD a través de GitHub Actions, y su ecosistema completo que incluye gestión de issues, pull requests, y wikis para documentación técnica. Esta plataforma facilita la colaboración entre equipos multidisciplinarios de desarrollo, proporcionando trazabilidad completa del código, versionado semántico, y controles de calidad esenciales para el proyecto de software.  
+__Hotfix branches:__ Para bugs urgentes en producción.
+Releases: Taggea versiones (e.g., v1.0) al final de sprints, alineado con fases CRISP-DM.
 
-#### Estrategía de Branching
+__Integra protecciones:__ En GitHub settings, requiere al menos 1 aprobación en PRs y status checks (tests) para merges.\
 
-###### Flujo de Ramas de Publicación en GitHub
-
-El flujo de publicación en GitHub sigue un patrón estructurado que garantiza la calidad y estabilidad del código. Inicia con la creación de ramas feature/ desde develop para nuevas funcionalidades, donde los desarrolladores implementan cambios específicos vinculados a tickets de Jira. Una vez completado el desarrollo, se crea un Pull Request (PR) hacia develop, donde se ejecutan automáticamente las pruebas de CI/CD, revisiones de código por pares y validaciones de calidad. Tras la aprobación y merge, los cambios se integran en develop para testing conjunto. Cuando se acumulan suficientes features, se crea una rama release/ que se somete a pruebas exhaustivas de QA antes de hacer merge a main/master para producción. En casos críticos, las ramas hotfix/ permiten correcciones directas desde main con despliegue inmediato. Este flujo asegura trazabilidad completa desde el desarrollo hasta producción, manteniendo la integridad del código y facilitando rollbacks cuando sea necesario.  
-![Ramas de publicación](https://wac-cdn.atlassian.com/dam/jcr:8f00f1a4-ef2d-498a-a2c6-8020bb97902f/03%20Release%20branches.svg)  
+![Ramas de publicación](https://wac-cdn.atlassian.com/dam/jcr:8f00f1a4-ef2d-498a-a2c6-8020bb97902f/03%20Release%20branches.svg)
 
-#### Principales Ramas de Trabajo LungLife
-
-###### Ramas Principales
-
-__main/master__    # Código en producción, versión estable  
-__develop__        # Rama principal de desarrollo, integración continua  
-
-1. __Ramas de Desarrollo de Funcionalidades__  
-   __feature/LUNG-XXX-nombre__    # Nuevas funcionalidades con ticket Jira  
-   __ml/experiment-name__         # Experimentos y modelos de machine learning  
-   __refactor/component-name__    # Reestructuración y optimización de código  
-2. __Ramas de Corrección y Mantenimiento__  
-   __bugfix/LUNG-XXX-issue__     # Corrección de errores no críticos  
-   __hotfix/LUNG-XXX-critical__  # Correcciones críticas urgentes en producción  
-   __patch/LUNG-XXX-minor__      # Correcciones menores y ajustes rápidos  
-   __maintenance/task-name__     # Tareas de mantenimiento y limpieza de código  
-3. __Ramas de Interfaz de Usuario__  
-   __ui/design-system-v2__       # Sistema de diseño, componentes reutilizables  
-   __ux/user-journey-fix__       # Optimización de experiencia de usuario  
-   __frontend/feature-name__     # Desarrollo específico de frontend   
-4. __Ramas de Backend e Infraestructura__  
-   __backend/api-endpoint__      # Desarrollo de APIs y lógica de servidor  
-   __infra/aws-setup__          # Configuración de infraestructura(cloud,servidores)  
-   __devops/pipeline-config__   # Automatización, CI/CD, contenedores   
-5. __Ramas de Despliegue y Entornos__  
-   __release/v1.2.0__           # Preparación de versiones para release  
-   __deploy/staging-config__    # Configuración específica de despliegues  
-   __config/environment-vars__  # Variables de entorno y configuraciones  
-   __setup/development-env__    # Setup inicial de entornos de desarrollo   
-6. __Ramas de Testing y Calidad__  
-   __test/integration-suite__   # Tests automatizados e integración  
-   __qa/regression-testing__    # Pruebas de calidad y regresión     
-7. __Ramas de Documentación y Gestión__  
-   __docs/api-documentation__   # Documentación técnica y de usuario  
-   __github/workflow-setup__    # Configuración de GitHub (templates, actions)  
-   __jira/automation-rules__    # Integración y automatización con Jira  
-   __privacy/gdpr-compliance__  # Cumplimiento de privacidad y regulaciones   
-
-#### Configuración de Entornos & Tools Env.
-
-###### IDE Visual Studio Code
-
-    August 2025 (version 1.104)
-
-Release date: September 11, 2025
-Update 1.104.1: The update addresses these issues.
-Update 1.104.2: The update addresses these issues.   
-
-###### IDE JETBRAINS
-
-###### DataSpell 2025.2
-
-    Build #DS-252.23892.514, built on August 11, 2025  
+#### Ramas principales
+main/master          # Código en producción
 
-###### WebStorm 2025.2.2
+develop             # Integración de features
 
-    Build #WS-252.26199.162, built on September 18, 2025 
+#### Ramas de trabajo
+feature/LUNG-123-login-screen     # Features (con ticket Jira)
 
-##### Data Base
+hotfix/LUNG-456-critical-bug      # Hotfixes
 
-##### PosgreSQL
+release/v1.2.0                    # Preparación releases
 
-    pgAdmin 4 Version 9.8
+ml/experiment-lung-detection      # Experimentos ML
 
-##### Abricotine
-
-    Abricotine - Markdown Editor
-    Copyright (c) 2020 Thomas Brouard
-
-> This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
+docs/api-documentation            # Documentación
